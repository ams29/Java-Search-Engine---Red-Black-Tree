
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.File;

public class TestRedBlackTree {

  RedBlackTree<Definition> rbt; // red black tree used for testing

  /**
   * tests a violation of rules that only requires a recolor
   */
  @Test
  public void recolor() {
    rbt = new RedBlackTree<Definition>();
    rbt.insert(new Definition("boolean ", "A data type that can hold True and False values only"));
    rbt.insert(new Definition("abstract ",
        "Specifies that a class or method will be implemented later, in a subclass"));
    rbt.insert(new Definition("catch ", "Catches exceptions generated by try statements"));
    rbt.insert(
        new Definition("double ", "A data type that can hold 64-bit floating-point numbers"));
    assertEquals("[boolean A data type that can hold True and False values only, "
        + "abstract Specifies that a class or method will be implemented later, in a subclass, "
        + "catch Catches exceptions generated by try statements, "
        + "double A data type that can hold 64-bit floating-point numbers]", rbt.toString());
  }

  /**
   * tests a violation of rules that requires a single rotation
   */
  @Test
  public void rotateTest() {
    rbt = new RedBlackTree<Definition>();
    rbt.insert(new Definition("boolean ", "A data type that can hold True and False values only"));
    rbt.insert(new Definition("catch ", "Catches exceptions generated by try statements"));
    rbt.insert(
        new Definition("double ", "A data type that can hold 64-bit floating-point numbers"));
    assertEquals("[catch Catches exceptions generated by try statements, "
        + "boolean A data type that can hold True and False values only, "
        + "double A data type that can hold 64-bit floating-point numbers]", rbt.toString());
  }

  /**
   * tests a violation of rules that requires a double rotation
   */
  @Test
  public void rotateTest2() {
    rbt = new RedBlackTree<Definition>();
    rbt.insert(new Definition("boolean ", "A data type that can hold True and False values only"));
    rbt.insert(
        new Definition("double ", "A data type that can hold 64-bit floating-point numbers"));
    rbt.insert(new Definition("catch ", "Catches exceptions generated by try statements"));
    System.out.println(rbt.toString());
    assertEquals("[catch Catches exceptions generated by try statements, "
        + "boolean A data type that can hold True and False values only,"
        + " double A data type that can hold 64-bit floating-point numbers]", rbt.toString());
  }

  /*
   * Data loading tests
   */

  /**
   * Tests adding data using the data loader with test data file and checks that all data is added
   * and that the nodes are in their correct order according to Red Black Tree rules.
   */
  @Test
  public void dataLoaderTest() {
    File data = new File("testData.txt");
    rbt = new RedBlackTree<Definition>();
    DataLoader d = new DataLoader(data, rbt);
    rbt = d.getMap();
    String compareString = "[import References other classes, "
        + "extends Indicates that a class is derived from another class or interface, "
        + "new Creates new objects, "
        + "char A data type that can hold unsigned 16-bit Unicode characters, "
        + "if Tests a true/false expression and branches accordingly, "
        + "long A data type that holds a 64-bit integer, "
        + "short A data type that can hold a 16-bit integer, "
        + "abstract Specifies that a class or method will be implemented later, in a subclass, "
        + "do Starts a do-while loop, package Declares a Java package]";
    assertEquals(compareString, rbt.toString());
  }


  /*
   * More Red Black tree function tests Author: Ethan Lim
   */

  /**
   * This test ensures that the data loader is working properly by asserting that the RBTree is not
   * null (or empty) when calling it's .toString() method
   */
  @Test
  public void testDataLoader() {
    rbt = new RedBlackTree<Definition>();
    File fp = new File("data1.txt");
    DataLoader test1 = new DataLoader(fp, rbt);

    assertNotNull(rbt.toString());
    
  }


  /**
   * This test ensures the RBTree is acting correctly for an insertion sequence that requires no
   * rotation is needed, only a recoloring operation
   */
  @Test
  public void testRecolor() {
    rbt = new RedBlackTree<Definition>();
    rbt.insert(new Definition("B ", "a letter"));
    rbt.insert(new Definition("A ", "a letter"));
    rbt.insert(new Definition("C ", "a letter"));
    rbt.insert(new Definition("D ", "a letter"));

    // compareTo() should return 0 if contents are equal
    assertEquals(0, rbt.root.data.toString().compareTo("B a letter"));
    assertEquals(true, rbt.root.rightChild.isBlack);
    assertEquals(true, rbt.root.leftChild.isBlack);
    assertEquals(false, rbt.root.rightChild.rightChild.isBlack);

  }


  /**
   * This test ensures the RBTree properly handles a red property violation (in this case, a left
   * rotate and recoloring is required)
   */
  @Test
  public void testRedViolation() {
    rbt = new RedBlackTree<Definition>();
    rbt.insert(new Definition("Avocado ", "a fruit"));
    rbt.insert(new Definition("Baskets ", "to hold avocados"));
    rbt.insert(new Definition("Clcoks ", "a time device"));

    // compareTo() should return 0 if contents are equal
    assertEquals(0, rbt.root.leftChild.data.toString().compareTo("Avocado a fruit"));
    assertEquals(0, rbt.root.data.toString().compareTo("Baskets to hold avocados"));
    
  }


  /**
   * This test ensures no fix is applied to a valid insertion sequence
   */
  @Test
  public void testNoViolation() {
    rbt = new RedBlackTree<Definition>();

    rbt.insert(new Definition("B ", "second letter"));
    rbt.insert(new Definition("A ", "first letter"));
    rbt.insert(new Definition("C ", "third letter"));

    assertEquals(0, rbt.root.data.toString().compareTo("B second letter"));
    assertEquals(false, rbt.root.rightChild.isBlack);
    assertEquals(false, rbt.root.leftChild.isBlack);
    
  }



}
